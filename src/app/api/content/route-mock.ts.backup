import { NextRequest, NextResponse } from "next/server"
import { getServerSession } from "next-auth/next"
import { authOptions } from "@/lib/auth"
import { z } from "zod"

// Mock data store (replace with actual database later)
let mockContent: any[] = [
  {
    id: "1",
    pageSlug: "home",
    sectionType: "HERO_SECTION",
    language: "en",
    status: "PUBLISHED",
    version: 1,
    createdBy: "admin-user-id",
    createdAt: new Date(),
    updatedAt: new Date(),
    publishedAt: new Date(),
    fields: [
      {
        id: "field-1",
        key: "badge",
        label: "Badge Text",
        type: "SHORT",
        value: "Innovating the Future",
        order: 0
      },
      {
        id: "field-2", 
        key: "title_part1",
        label: "Title Part 1",
        type: "SHORT",
        value: "Transforming",
        order: 1
      },
      {
        id: "field-3",
        key: "subtitle",
        label: "Subtitle", 
        type: "LONG",
        value: "We're not just another tech startup. We're building the Future.",
        order: 2
      }
    ],
    buttons: [
      {
        id: "button-1",
        label: "Launch Button",
        text: "Launch Your Vision",
        url: "/launch",
        order: 0
      }
    ]
  },
  {
    id: "2",
    pageSlug: "home",
    sectionType: "HERO_SECTION", 
    language: "th",
    status: "PUBLISHED",
    version: 1,
    createdBy: "admin-user-id",
    createdAt: new Date(),
    updatedAt: new Date(),
    publishedAt: new Date(),
    fields: [
      {
        id: "field-1-th",
        key: "badge",
        label: "Badge Text",
        type: "SHORT",
        value: "Innovating the Future",
        order: 0
      },
      {
        id: "field-2-th",
        key: "title_part1", 
        label: "Title Part 1",
        type: "SHORT",
        value: "เปลี่ยน IDEAS",
        order: 1
      },
      {
        id: "field-3-th",
        key: "subtitle",
        label: "Subtitle",
        type: "LONG", 
        value: "เราไม่ใช่แค่สตาร์ทอัพด้านเทคโนโลยี แต่เรากำลังสร้างอนาคต",
        order: 2
      }
    ],
    buttons: [
      {
        id: "button-1-th",
        label: "Launch Button",
        text: "เปิดตัววิสัยทัศน์ของคุณ", 
        url: "/launch",
        order: 0
      }
    ]
  }
]

// Validation schemas
const createContentSchema = z.object({
  pageSlug: z.string().min(1),
  sectionType: z.enum(["HERO_SECTION", "PROBLEM_SECTION", "FEATURES_SECTION", "TESTIMONIALS", "FAQ"]),
  language: z.string().default("en"),
  fields: z.array(z.object({
    key: z.string(),
    label: z.string(),
    type: z.enum(["SHORT", "LONG"]),
    value: z.string(),
    order: z.number().default(0)
  })),
  buttons: z.array(z.object({
    label: z.string(),
    text: z.string(),
    url: z.string(),
    order: z.number().default(0)
  })).optional()
})

const updateStatusSchema = z.object({
  status: z.enum(["DRAFT", "REVIEW", "PUBLISHED", "ARCHIVED"]),
  contentId: z.string()
})

// GET - Fetch content
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const pageSlug = searchParams.get("pageSlug")
    const sectionType = searchParams.get("sectionType")
    const language = searchParams.get("language") || "en"
    const status = searchParams.get("status")
    const includeUnpublished = searchParams.get("includeUnpublished") === "true"

    // Check authentication for unpublished content
    if (includeUnpublished || (status && status !== "PUBLISHED")) {
      const session = await getServerSession(authOptions)
      if (!session?.user) {
        return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
      }

      // Mock admin check (replace with actual role check)
      // const hasAdminRole = session.user.email === "admin@uplift.com"
      // if (!hasAdminRole) {
      //   return NextResponse.json({ error: "Forbidden" }, { status: 403 })
      // }
    }

    let filteredContent = [...mockContent]

    // Apply filters
    if (pageSlug) {
      filteredContent = filteredContent.filter(c => c.pageSlug === pageSlug)
    }
    if (sectionType) {
      filteredContent = filteredContent.filter(c => c.sectionType === sectionType)
    }
    if (language) {
      filteredContent = filteredContent.filter(c => c.language === language)
    }
    if (!includeUnpublished) {
      filteredContent = filteredContent.filter(c => c.status === "PUBLISHED")
    } else if (status) {
      filteredContent = filteredContent.filter(c => c.status === status)
    }

    return NextResponse.json({ data: filteredContent })
  } catch (error) {
    console.error("Error fetching content:", error)
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    )
  }
}

// POST - Create new content
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    const body = await request.json()
    const validatedData = createContentSchema.parse(body)

    const newContent = {
      id: `content-${Date.now()}`,
      pageSlug: validatedData.pageSlug,
      sectionType: validatedData.sectionType,
      language: validatedData.language,
      status: "DRAFT",
      version: 1,
      createdBy: session.user.id || "mock-user-id",
      createdAt: new Date(),
      updatedAt: new Date(),
      fields: validatedData.fields.map((field, index) => ({
        id: `field-${Date.now()}-${index}`,
        key: field.key,
        label: field.label,
        type: field.type,
        value: field.value,
        order: field.order
      })),
      buttons: validatedData.buttons?.map((button, index) => ({
        id: `button-${Date.now()}-${index}`,
        label: button.label,
        text: button.text,
        url: button.url,
        order: button.order
      })) || []
    }

    mockContent.push(newContent)

    return NextResponse.json({ data: newContent }, { status: 201 })
  } catch (error) {
    console.error("Error creating content:", error)
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation error", details: error.issues },
        { status: 400 }
      )
    }

    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    )
  }
}

// PUT - Update content status
export async function PUT(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    const body = await request.json()
    const { status, contentId } = updateStatusSchema.parse(body)

    const contentIndex = mockContent.findIndex(c => c.id === contentId)
    if (contentIndex === -1) {
      return NextResponse.json({ error: "Content not found" }, { status: 404 })
    }

    mockContent[contentIndex] = {
      ...mockContent[contentIndex],
      status,
      updatedAt: new Date(),
      ...(status === "PUBLISHED" && {
        publishedBy: session.user.id || "mock-user-id",
        publishedAt: new Date()
      })
    }

    return NextResponse.json({ data: mockContent[contentIndex] })
  } catch (error) {
    console.error("Error updating content status:", error)
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation error", details: error.issues },
        { status: 400 }
      )
    }

    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    )
  }
}